% This is sigproc-sp.tex -FILE FOR V2.6SP OF ACM_PROC_ARTICLE-SP.CLS
% OCTOBER 2002
%
% It is an example file showing how to use the 'acm_proc_article-sp.cls' V2.6SP
% LaTeX2e document class file for Conference Proceedings submissions.
% ----------------------------------------------------------------------------------------------------------------
% This .tex file (and associated .cls V2.6SP) *DOES NOT* produce:
%       1) The Permission Statement
%       2) The Conference (location) Info information
%       3) The Copyright Line with ACM data
%       4) Page numbering
%
%  However, both the CopyrightYear (default to 2002) and the ACM Copyright Data
% (default to X-XXXXX-XX-X/XX/XX) can still be over-ridden by whatever the author
% inserts into the source .tex file.
% e.g.
% \CopyrightYear{2003} will cause 2003 to appear in the copyright line.
% \crdata{0-12345-67-8/90/12} will cause 0-12345-67-8/90/12 to appear in the copyright line.
%
% ---------------------------------------------------------------------------------------------------------------
% It is an example which *does* use the .bib file (from which the .bbl file
% is produced).
% REMEMBER HOWEVER: After having produced the .bbl file,
% and prior to final submission,
% you need to 'insert'  your .bbl file into your source .tex file so as to provide
% ONE 'self-contained' source file.
%
% Questions regarding SIGS should be sent to
% Adrienne Griscti ---> griscti@acm.org
%
% Questions/suggestions regarding the guidelines, .tex and .cls files, etc. to
% Gerald Murray ---> murray@acm.org 
%
% For tracking purposes - this is V2.6SP - OCTOBER 2002


\documentclass[12pt]{article}

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\topmargin}{0in}
\setlength{\headheight}{0in}
\setlength{\headsep}{0in}
\setlength{\textwidth}{6in}
\setlength{\textheight}{9in}
\setlength{\parindent}{0in} 

\usepackage{graphicx} %For jpg figure inclusion
\usepackage{times} %For typeface
\usepackage{epsfig}
\usepackage{color} %For Comments
%\usepackage[all]{xy}
\usepackage{float}
%\usepackage{subfigure} 
\usepackage{url}
\usepackage{parskip}

%% Elena's favorite green (thanks, Fernando!)
\definecolor{ForestGreen}{RGB}{34,139,34}
% Uncomment this if you want to show work-in-progress comments
\newcommand{\comment}[1]{{\bf \tt  {#1}}}
% Uncomment this if you don't want to show comments
%\newcommand{\comment}[1]{}
\newcommand{\emcomment}[1]{\textcolor{ForestGreen}{\comment{Elena: {#1}}}}
\newcommand{\todo}[1]{\textcolor{blue}{\comment{To Do: {#1}}}}

\newcommand{\pscomment}[1]{\textcolor{red}{\comment{Paul: {#1}}}}
\newcommand{\mmcomment}[1]{\textcolor{magenta}{\comment{Max: {#1}}}}
\begin{document}
\pagestyle{plain}
%
% --- Author Metadata here ---
%\conferenceinfo{WOODSTOCK}{'97 El Paso, Texas USA}
%\setpagenumber{50}
%\CopyrightYear{2002} % Allows default copyright year (2002) to be
%over-ridden - IF NEED BE. 
%\crdata{0-12345-67-8/90/01}  % Allows default copyright data
%(X-XXXXX-XX-X/XX/XX) to be over-ridden. 
% --- End of Author Metadata ---

\title{Developing a Graphical Library for a Clojure-based Introductory CS Course}
%\subtitle{[Extended Abstract \comment{DO WE NEED THIS?}]
%\titlenote{}}
%
% You need the command \numberofauthors to handle the "boxing"
% and alignment of the authors under the title, and to add
% a section for authors number 4 through n.
%
% Up to the first three authors are aligned under the title;
% use the \alignauthor commands below to handle those names
% and affiliations. Add names, affiliations, addresses for
% additional authors as the argument to \additionalauthors;
% these will be set for you without further effort on your
% part as the last section in the body of your article BEFORE
% References or any Appendices.

\author{
Paul Schliep, Max Magnuson, and Elena Machkasova \\
Computer Science Discipline \\
University of Minnesota Morris\\
Morris, MN 56267\\
schli202@umn.edu, magnu401@umn.edu, elenam@umn.edu
}

\date{}

\maketitle
\thispagestyle{empty}

\section*{\centering Abstract}
UMM introductory CS curriculum emphasizes problem solving and general approaches to programming, such as modularity. Languages in the Lisp family, such as Racket, fit well with this emphasis. Currently, the language Racket is being used in an introductory course at UMM and has beneficial aspects for teaching functional approaches for CS design and a robust graphical library. However, Racket is primarily used as a teaching language and is not often used outside of the classroom setting. In contrast, Clojure, a novel language in the Lisp family, is used more often in real world settings and provides better parallel processing and integration with other languages. Therefore, using Clojure in an introductory class would be potentially more beneficial for students. The focus of our project is developing a graphical library in Clojure for introductory-level students. This is a part of a larger ongoing project to integrate Clojure into a college-level introductory CS course.

Since functional languages focus on functions as programming units, provide abstraction, generalization, modularity, and give a better understanding of recursion (one of the key learning goals in an introductory CS course), we feel it is important that the graphical library used by students implements these functional approaches and is consistent with the functional programming in Clojure. In order to accomplish our goal, we want to create a graphical library that is similar to the one in Racket because it teaches introductory students problem solving skills and modularity with functional approaches in an engaging and entertaining setting. We are developing this library using the existing software package Quil, which is written in Clojure. However, Quil’s design is built upon Java Swing, so it focuses on sequences of commands that directly manipulate memory, which goes against the learning objectives of a class that focuses on functional approaches.

We are developing a collection of functions similar to that of the Model-View Control of Racket’s graphical library on top of Quil’s existing library to address the learning objectives of functional programming and hide the imperative approaches currently in Quil. In this system students program using functions that take a state of the system (such as a position of a game character on a board) and return a new state (such as a new position and/or an image representing the character), without direct memory manipulation.

We have designed and developed a collection of functions that abstract over Quil’s direct manipulation of the system’s state so that the state updates and displays using separate functions in a way that is geared toward introductory-level students. In this paper we present the main set of functions and examples of their usage. 
\emcomment{As submitted to MICS; needs to be changed}


\newpage
\setcounter{page}{1}

\section{Introduction}\label{sec:intro}
\todo{Overview of project and goals, Paul's section}
UMM offers an introductory CS course on teaching the concepts of problem solving and programming using the language Racket. 
\emcomment{add a reference to Racket book, add a sentence explaining that it's a functional language in Lisp family} The course utilizes functional approaches of Racket in order for students to better learn the general paradigms of programming.  \emcomment{Explain} However, since Racket is not often used in real world settings, it does not benefit students as much in their future CS careers. Clojure, which is a functional language similar to Racket \emcomment{Replace by "also in the Lisp category"}, offers better concurrency, integration with Java, and is widely \emcomment{I would say "is gaining popularity in industry"} used in industry, would better suit students in an introductory CS course.  We plan to integrate Clojure into this introductory course in place of Racket because of the benefits it offers, but in order to do so, we need to resolve some of the limitations of Clojure before it can be ready for use in the introductory course. One such limitation is Clojure's lack of a fully functional graphical library suitable for an introductory CS course.  

Racket has a full graphical API that is useful for students to create a wide array of programs and also remains consistent with the functional design of Racket. Since graphics are a key component in an introductory CS course, it is important that we implement a graphical API with user-friendly functions for introductory CS students. To fill the gap, we are integrating Quil, an open source graphical environment, into the course \emcomment{Add a URL to the bibliography and a reference}. Quil shows promise since it has a large feature set appropriate for introductory students to create a wide array of graphical programs \emcomment{give a couple of examples}. However, since Quil was built on top of Java Swing library, it has imperative design approaches to creating programs that would take students out of the functional approaches from Clojure. It is important that functional approaches remain consistent throughout the course, and having a graphical library of imperative approaches would not be ideal for teaching to beginning CS students. So, to keep the consistency of Clojure's functional approaches and continue teaching the key concepts of the introductory course, we will be creating a graphical set of functions built from Quil API that has similar functional approaches as Racket's graphical API. In order to do so, we %plan on 
abstract over many of the functions offered by Quil that will be more in line for functional programming \emcomment{It sounds like the current set of functions is in line with functional approaches; rewrite}. While there have been many technical difficulties in working with Quil on creating this graphical set of functions, we have been able to successfully abstract over many of Quil's current functions to create a system that’s closer to the functional design of Clojure. 

\section{Overview of Clojure}\label{sec:clojure}
\todo{Max's section}
Clojure is a functional programming language in the Lisp \emcomment{usually only the first letter is capitalized} family of languages. Clojure was developed by Rich Hickey and released in 2007~\cite{Hickey:2008}. Clojure was developed with a strong emphasis on functional programming with its immutable data types and first class functions. Also Clojure provides a rich set of data structures that are immutable, such as lists, vectors, and hashmaps.
\emcomment{We need to remind the reader about what functional and imperative is. Not here, but somewhere?}

Immutable data types are data types that cannot be changed. In Clojure when a change to an item of data is needed, a new data item will be made with that new value. The use of immutable data types in Clojure gives it a significant advantage over imperative languages when it comes to parallel processing. Mutable data types in imperative languages can cause a variety of issues. For instance, if the value 1 is stored and two functions running in parallel need to access that value, increment it, and then store the new value. The expected result should be three, but that will not always be true. If the two functions access the value while it is still one, increment it, then save it as the new value of two, the resulting value will be two instead of three. This situation is called a race condition. A race condition are inconsistencies that arise when the order in which parallel processes work can cause unintended results.
\mmcomment{I don't think the above example is solvable with immutable data types. I need to come up with a better example. Also should I explain persistent data types?}
\emcomment{Good point. Perhaps think of an object with several fields that becomes inconsistent because parts of it are modified separately}

First class functions are functions that are able to be passed as arguments into other functions, returned from functions, or storing them in data structures.
\mmcomment{I will come up with some example code to better illustrate this concept, and more explanation will go along with the example code.}   

\section{Goals and Setup for an Introductory Course}\label{sec:racket-clojure}
\emcomment{Section~\ref{subsec:plans} assumes that we have already talked about Clojure-Java integration and usefulness in the work filed. This may or may not belong here, but it has to be somewhere.}

\pscomment{I added some of the clojure-java integration and usefulness in my section for plans on introducing Clojure.  It can still be added here, but wouldn't be necessary anymore.}

\subsection{Overview of Current UMM CS Introductory Course}\label{subsec:course}
\todo{Elena's subsection}
~\cite{htdp}
~\cite{lein} \emcomment{Look into including URLs}

\subsection{Plans for Introducing Clojure}\label{subsec:plans}
\todo{Paul's section}

The current UMM introductory CS curriculum implements Racket because of its ease of use and functional design make it beneficial for teaching the learning objectives of an introductory CS course.  However, since Racket is primarily a teaching language and is not often used outside of the classroom environment, it isn’t beneficial for students in the work field. Clojure, however, is better suited for students in their future CS careers as it has integration with Java and is widely used in the work field. What also makes Clojure ideal is it retains the same functional design implemented in Racket. Functional design in an introductory course is important since it teaches students many fundamentals of programming and problem solving such as recursion, modularity, and the importance of immutability. The benefit of teaching these concepts using functional approaches over imperative approaches is functional programming is without side effects because of its immutability and stateless design that beginning CS students shouldn’t need to worry about in an introductory course. Functional programming is ideal for learning problem solving as well since it teaches students to think in a different way than what most are use to and can help students engage in other languages more easily.

Clojure’s integration with Java and usefulness in the work field are just some of the perks that we feel can be beneficial to students in preparing for their future careers in computer science.  Although Clojure provides many important benefits not seen in Racket, it is not yet a language ready for using in an introductory CS course. In order to make it a usable language, many steps must be taken in order to accommodate for Clojure’s high learning curve that prevents it from being usable for beginner-level CS students.

One barrier preventing Clojure from being used in an introductory CS course is its error messages. Often, they tend to be unintuitive and unnecessarily long and can be hard to understand for experienced programmers, much less beginning CS students. Also, there is not an environment that supports easy navigation of the error messages and connecting them to their location of the offending line of code (such as highlighting that line of code). Since problem solving is a core learning objective of the introductory course, it is essential for error messages to be usable for beginning students to enable them to easily troubleshoot issues and focus on key learning concepts. To solve these issues, we catch the error messages and throw more user-friendly messages appropriate for introductory CS students. 

Along with the lack of an appropriate user interface for error messages, there is also an absence of a complete development environment for students to easily program in. The current UMM introductory CS course that uses Racket integrates an IDE called DrRacket that incorporates a user-friendly interface for students to develop programs in, something that is necessary for an introductory CS course.  Currently, there is an IDE that is still in development called Light Table.  Since Light Table was designed for programming in Clojure and was created with usability in mind, it shows promise in usability by which introductory computer science students can program. We are currently exploring ways of integrating our error message handling with Light Table before it can be useful for an introductory course. 

A graphical environment in an introductory course provides good motivation for students to explore the language and practice their programming skills. Currently, there is no built in system for graphical functions in Clojure and there is no beginner-friendly graphical library that teaches the learning objectives of functional programming in an introductory CS course. A potential graphical library to use for programming is an open-source project called Quil that has many of the functions necessary for students to use in an introductory CS course.
\emcomment{example? Perhaps a screen shot of shapes and such?}
\pscomment{Taken from Quil's github, we should probably use our own, which I will try to get soon.  Screenshot: http://cloud.github.com/downloads/quil/quil/readme-oh-so-many-grey-circles.png}

However, there are limitations and potential issues to using this graphical library that will steer away from the learning objectives and functional approaches that UMM’s introductory CS curriculum has in place.


\subsection{Requirements for a Graphical Library}\label{subsec:requirements}
\todo{Talk about state and how to handle in a functional way, Max's section}
Racket's graphical library has proven to be a powerful teaching tool in the current UMM CS introductory course by allowing students to make animations less than a month into the semester. This maintains interest in programming while reinforcing key concepts. With this in mind, we looked for a graphical library in Clojure that would be appropriate for an introductory class that focuses on functional approaches and problem solving. In our search for graphical libraries in Clojure we came across Quil. Quil is a developing graphical library written in Clojure that takes Clojure code and produces graphics using Java Swing. While promising, Quil had some issues that needed to be addressed before it could be used as a suitable graphical library for the introductory course.

State in Quil contains all of the data to maintain and draw the graphics on screen. For example, a picture of a rocket would have certain properties that are needed to draw it such as position, size, color, and transparency. Each of these properties are stored by the state and used to draw the rocket. The process of updating the state and drawing the state are completed using the same function. Since this process is combined, the order in which steps are taking is very important. Parts of the state need to be updated before drawing them, and those parts need to be drawn in the correct order in case the layering matters. If we needed to draw a wheel on a car that was moving across the screen, first the tire's properties would be updated then drawn then the rim's properties would be updated and drawn. This order would maintain the shape of the wheel because the tire would not be obscuring the rim and it requires multiple steps of updating state.While their system works well, it is very imperative in its design which defeats the intent of teaching functional approaches. To address the issues of the imperative design we emulated the model-view-controller system of Racket's graphical library and modularized the process. 

Racket's graphical library works by separating state into three different processes using model-view-controller (MVC). The view is the actual visual representation of the graphics. The controller listens for changes. The model takes in the changes from the controller and updates the state for the view to then reflect the changes. This modularization of the work allows for the use of immutable objects to be passed around and used as opposed to direct memory manipulation.

In our design of the graphical library we needed to separate the processes of updating state and displaying state. In order to accomplish this we developed a system that would take in as setup: 
\begin{itemize}
	\item A collection of graphics variables 
	\item A collection of functions to update state
	\item An ordered collection of functions used to display graphics 
\end{itemize}
This design accomplishes both abstracting over direct memory manipulation and making order matter less. Our design abstracts over direct memory manipulation by taking care of changing variables for the user \emcomment{show an example of this; perhaps a diagram would be helpful}. When a part of the state is updated it is saved to a variable by the system not by the function that is provided by the user. Then when the graphics are displayed it accesses that variable and draws what is stored. This design makes order matter less by encapsulating updating state and displaying state \emcomment{Again, give an example (of ``before' and ``after'', i.e.. how it would've been done in Quil and how it is done now)}. The order in which the state is updated is completely irrelevant and can happen independently of displaying state. Unfortunately displaying state requires order, but it is a necessity since issues of layering could come up if display wasn't ordered.
\emcomment{need an example}

\section{Developing a Clojure Graphical Library}\label{sec:library}

\subsection{Overview of Quil}\label{subsec:quil}
\todo{technical difficulties, imperative approaches, etc. Paul's section}
Graphics are an important aspect on teaching students the basis for programming in an introductory CS course. They give students a visual representation of their programs and give an appealing incentive to practice their programming skills, problem solving, and develop a sense of functional approaches. To fill Clojure’s lack of a graphical API, we will be using an open-source graphical API called Quil.

Quil is an open-source graphical API developed for creating functions that display and transform graphical elements in Clojure. It provides the user a library of easy-to-use functions such as creating shapes or changing colors that can be used for an array of projects for students in an introductory-level CS course. These projects can range from creating a drawing of a sine wave to a game such as tic tac toe. SInce Quil is built on top of Java Swing, it uses Java applets to display the graphical images and updates them constantly using a system of a state of frames that the user manipulates in order to animate drawings. However, Quil has some limitations that prevent it from being usable for an introductory CS course that teaches introductory students functional approaches to programming.

An apparent limitation of Quil is since it is built on top of Java Swing, it has imperative approaches and functionality that would not be acceptable for students to learn in a class based on functional programming. For example, the manipulation of world state in Quil is setting the state and then it displays and updates the state simultaneously in a draw function which directly manipulates memory, something that goes against the model-view control of functional programming. In order to keep the consistency of the functional approaches of Clojure, we are working on creating a graphical library of functions with design that implements functional approaches similar to Racket’s graphical library that we plan to abstract over Quil’s functionality. There have been many technical difficulties imposed by Quil however on attempting to create this graphical library.

Creating programs in Quil’s environment consists of a step by step basis: creating a setup function for setting the initial background color, setting the speed of the framerate, etc; developing a draw function for creating shapes and colors that will be transformed as necessary; and a \tt{defsketch}, a macro used to call the setup, draw, and creating the title and size of the window. In order for Quil to be able to run programs, the user must use the \tt{defsketch} for the work to be displayed. So, when trying to abstract over Quil’s system of the state to a system that follows the model view control similar to Racket’s graphical library, there is a gap on having the be updated and displayed separately due to Quil’s dependency on \tt{defsketch} that calls the draw function (which displays and updates the functions simultaneously).  Since \tt{defsketch} takes the user out of the functional programming, we also thought it would be necessary to attempt to hide the \tt{defsketch} from the student, which we realized would need to be auto generated by a macro due to the strong dependencies of \tt{defsketch} set up by Quil.
\begin{verbatim} 
(defsketch example                  ;; Define a new sketch named example
  :title "Example"                  ;; Set the title of the sketch
  :setup setup                      ;; Specify the setup fn
  :draw draw                        ;; Specify the draw fn
  :size [500 400])                  ;; Specify the size of the window
\end{verbatim}
On first learning to use Quil, it was clear that the documentation was limited on how the functions actually work. This posed an issue when making new functions that abstract over the current ones. This includes both the API’s documentation as well as the documentation within the source code. So, when trying to understand how many of the functions worked (such as state), we had to scour the source code to find a proper answer. To ensure students won’t have this issue, we plan to ensure that our graphical library will have a full API that details each function as well as appropriate examples for each.  


\subsection{Introducing Functional Approaches}\label{subsec:functional}
\todo{Max's section}
Functional approaches to programming are stylistic choices that utilize the structure of functional programming. In designing our graphical library we focused on reducing the amount that order mattered and limiting the need for the user to directly manipulate memory. These are two concepts that are common practice in functional programming.

\section{Examples of Usage of the Graphical Library}\label{sec:usage}
\todo{Add examples as we are writing.  Make it into a section once we know what's in it.}

\section{Conclusions and Future Work}\label{sec:future-work}


%
% The following two commands are all you need in the
% initial runs of your .tex file to
% produce the bibliography for the citations in your paper.
%\bibliographystyle{abbrv}
%\end{thebibliography}

%\bibliography{generic_types}  
% You must have a proper ".bib" file
%  and remember to run:
% latex bibtex latex latex
% to resolve all references
%
% ACM needs 'a single self-contained file'!
%
\bibliographystyle{ACM}
\bibliography{mics2014introclass}


% That's all folks!
\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
